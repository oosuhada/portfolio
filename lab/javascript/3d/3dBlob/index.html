<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Animated Blob</title>
    <style>
        /* CSS: 웹 페이지의 스타일을 정의합니다. */
        body { 
            margin: 0; 
            overflow: hidden; /* 스크롤바를 없앱니다. */
            background: #111; /* 배경색을 어두운 회색으로 설정합니다. */
        }
        canvas { 
            display: block; /* 캔버스를 블록 요소로 만듭니다. */
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    //-- JavaScript (three.js): 3D 그래픽을 생성하고 애니메이션을 구현합니다. --//

    // 1. 기본 설정 (Scene, Camera, Renderer)
    const scene = new THREE.Scene(); // 3D 공간(장면)을 생성합니다.
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); // 원근감이 있는 카메라를 설정합니다.
    const renderer = new THREE.WebGLRenderer({  // WebGL 렌더러(그림을 그리는 도구)를 설정합니다.
        alpha: true // 배경을 투명하게 처리할 수 있도록 합니다.
    });

    renderer.setSize(window.innerWidth, window.innerHeight); // 렌더러의 크기를 창 크기에 맞춥니다.
    renderer.setPixelRatio(window.devicePixelRatio); // 고해상도 디스플레이를 지원합니다.
    document.body.appendChild(renderer.domElement); // 렌더러가 만든 캔버스 요소를 HTML의 body에 추가합니다.

    // 2. 블롭(Blob) 오브젝트 생성
    // 구 형태의 지오메트리(뼈대)를 고해상도(128x128)로 생성합니다.
    const geometry = new THREE.SphereGeometry(1, 128, 128); 
    
    // 매끄러운 흰색 재질을 설정합니다.
    const material = new THREE.MeshStandardMaterial({
        color: 0xffffff, // 색상: 흰색
        roughness: 0.2,    // 거칠기 (0에 가까울수록 매끈)
        metalness: 0.1,    // 금속성 (1에 가까울수록 금속 같음)
        flatShading: false, // 표면을 매끄럽게 렌더링
    });

    // 지오메트리와 재질을 합쳐 '블롭' 메쉬(3D 모델)를 만듭니다.
    const blob = new THREE.Mesh(geometry, material);
    scene.add(blob); // 만든 블롭을 3D 공간에 추가합니다.

    // 3. 조명 설정
    const ambientLight = new THREE.AmbientLight(0x404040); // 은은하게 전체를 비추는 주변광을 추가합니다.
    scene.add(ambientLight);
    
    const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1); // 특정 방향에서 비추는 직사광선을 추가합니다. (태양광과 유사)
    directionalLight1.position.set(1, 1, 1); // 빛의 방향 설정
    scene.add(directionalLight1);
    
    const pointLight = new THREE.PointLight(0xffffff, 1, 10); // 특정 지점에서 사방으로 퍼지는 점광원을 추가합니다. (전구와 유사)
    pointLight.position.set(2, 3, 4); // 빛의 위치 설정
    scene.add(pointLight);

    // 4. 카메라 위치 설정
    camera.position.z = 3; // 카메라를 Z축 방향으로 3만큼 뒤로 이동시켜 블롭이 보이게 합니다.

    // 5. 애니메이션을 위한 변수 설정
    let time = 0; // 시간의 흐름을 기록할 변수
    const positions = geometry.attributes.position; // 지오메트리의 모든 정점(vertex) 위치 정보
    const originalPositions = positions.array.slice(); // 변형되지 않은 원래 정점 위치를 복사해둡니다.
    const smoothness = 0.3; // 정점 변형의 강도를 조절하는 값

    // 6. 창 크기 조절 처리
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight; // 카메라의 종횡비를 창 크기에 맞게 업데이트합니다.
        camera.updateProjectionMatrix(); // 카메라의 변경사항을 적용합니다.
        renderer.setSize(window.innerWidth, window.innerHeight); // 렌더러의 크기도 창 크기에 맞춥니다.
    });

    // 7. 애니메이션 루프 함수
    function animate() {
        requestAnimationFrame(animate); // 매 프레임마다 animate 함수를 다시 호출하여 부드러운 애니메이션을 만듭니다.
        
        time += 0.004; // 시간을 조금씩 증가시켜 애니메이션을 진행합니다.
        
        // 블롭의 정점을 변형하여 움직이는 효과를 줍니다.
        for (let i = 0; i < positions.count; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;
            
            const x = originalPositions[ix];
            const y = originalPositions[iy];
            const z = originalPositions[iz];
            
            // sin, cos 함수와 시간 값을 이용하여 각 정점의 변위(displacement)를 계산합니다.
            // 이를 통해 유기적이고 물결치는 듯한 움직임이 만들어집니다.
            const displacement = smoothness * (Math.sin(x * 3 + time * 1.5) + 
                                  Math.cos(y * 4 + time * 1.3) + 
                                  Math.sin(z * 2 + time * 0.7)) / 3;
            
            // 원래 위치에 변위를 적용하여 정점의 위치를 업데이트합니다.
            positions.array[ix] = x + x * displacement;
            positions.array[iy] = y + y * displacement;
            positions.array[iz] = z + z * displacement;
        }
        
        positions.needsUpdate = true; // 정점 위치가 변경되었음을 three.js에 알립니다.
        geometry.computeVertexNormals(); // 변형된 표면에 맞게 빛 계산을 위한 법선 벡터를 다시 계산합니다.
        
        // 블롭 전체를 서서히 회전시킵니다.
        blob.rotation.x = time * 0.05;
        blob.rotation.y = time * 0.1;
        
        renderer.render(scene, camera); // 최종적으로 업데이트된 장면을 화면에 그립니다.
    }

    animate(); // 애니메이션 루프를 시작합니다.
    </script>
</body>
</html>