<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>110vw/110vh Canvas Offcenter</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      /* width/height 지정 불필요, JS에서 canvas로 제어 */
    }
    body {
      background: #eee;
    }
    /* canvas의 스타일은 JS에서 설정 */
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    "use strict";

    let canv, ctx; // canvas and context
    let maxx, maxy; // canvas dimensions

    let xc, yc, R; // circle projection of sphere
    let dotRadius;

    let arp; // array of points
    const nbPoints = 100;
    let gr;

    let ang1 = 0, ang2 = 0;
    let dRot1, dRot2; // functions to increment rotation
    const rotSpeed = 0.005;
    const minDist = 0.25; // minimal distance between points, relative to sphere radius

    // shortcuts for Math.
    const mrandom = Math.random;
    const mfloor = Math.floor;
    const mround = Math.round;
    const mceil = Math.ceil;
    const mabs = Math.abs;
    const mmin = Math.min;
    const mmax = Math.max;

    const mPI = Math.PI;
    const mPIS2 = Math.PI / 2;
    const mPIS3 = Math.PI / 3;
    const m2PI = Math.PI * 2;
    const m2PIS3 = (Math.PI * 2) / 3;
    const msin = Math.sin;
    const mcos = Math.cos;
    const matan2 = Math.atan2;

    const mhypot = Math.hypot;
    const msqrt = Math.sqrt;

    function hslString(h, s = 100, l = 50) {
      return `hsl(${h},${s}%,${l}%)`;
    }

    function alea(mini, maxi) {
      if (typeof maxi == "undefined") return mini * mrandom();
      return mini + mrandom() * (maxi - mini);
    }
    function intAlea(mini, maxi) {
      if (typeof maxi == "undefined") return mfloor(mini * mrandom());
      return mini + mfloor(mrandom() * (maxi - mini));
    }

    function Noise1DOneShot(period, min = 0, max = 1, random) {
      random = random || Math.random;
      let currx = random();
      let y0 = min + (max - min) * random();
      let y1 = min + (max - min) * random();
      let dx = 1 / period;

      return function () {
        currx += dx;
        if (currx > 1) {
          currx -= 1;
          y0 = y1;
          y1 = min + (max - min) * random();
        }
        let z = (3 - 2 * currx) * currx * currx;
        return z * y1 + (1 - z) * y0;
      };
    }

    function arrayShuffle(array) {
      let k1, temp;
      for (let k = array.length - 1; k >= 1; --k) {
        k1 = intAlea(0, k + 1);
        temp = array[k];
        array[k] = array[k1];
        array[k1] = temp;
      }
      return array;
    }

    function Pos(R = 1) {
      this.lat = Math.asin(alea(-1, 1));
      this.long = alea(m2PI);
      this.x = R * mcos(this.long) * mcos(this.lat);
      this.y = R * msin(this.lat);
      this.z = R * msin(this.long) * mcos(this.lat);
      this.hue = intAlea(360);
      this.sat = intAlea(60, 100);
      this.R = R;
    }
    Pos.prototype.distance = function (otherPos) {
      return mhypot(this.x - otherPos.x, this.y - otherPos.y, this.z - otherPos.z);
    };

    let animate, messages = [];

    {
      let animState = 0;

      animate = function (tStamp) {
        let message;
        let m00, m01, m02;
        let m10, m11, m12;
        let m20, m21, m22;
        let s1, s2, c1, c2;

        message = messages.shift();
        if (message && message.message == "reset") animState = 0;
        window.requestAnimationFrame(animate);
        switch (animState) {
          case 0:
            startOver();
            ++animState;
          case 1:
            ang1 += dRot1();
            ang2 += dRot2();
            s1 = msin(ang1);
            c1 = mcos(ang1);
            s2 = msin(ang2);
            c2 = mcos(ang2);

            m00 = c2;
            m01 = s2 * s1;
            m02 = s2 * c1;
            m11 = c1;
            m12 = -s1;

            m20 = -s2;
            m21 = s1 * c2;
            m22 = c1 * c2;

            ctx.fillStyle = gr;
            ctx.fillRect(0, 0, maxx, maxy);
            ctx.lineWidth = 1;
            arp.forEach((point) => {
              point.dx = m00 * point.x + m01 * point.y + m02 * point.z;
              point.dy = m11 * point.y + m12 * point.z;
              point.dz = m20 * point.x + m21 * point.y + m22 * point.z;
              point.dz /= point.R;
            });

            arp.sort((pointa, pointb) => pointa.dz - pointb.dz);

            arp.forEach((point) => {
              let gr = ctx.createRadialGradient(
                xc + point.dx + 0.4 * dotRadius,
                yc + point.dy - 0.4 * dotRadius,
                0,
                xc + point.dx,
                yc + point.dy,
                dotRadius
              );
              let lum = 50 + 20 * point.dz;
              gr.addColorStop(0, hslString(point.hue, point.sat, lum));
              gr.addColorStop(0.6, hslString(point.hue, point.sat, lum * 0.7));
              gr.addColorStop(1, hslString(point.hue, point.sat, 20 + 10 * point.dz));
              ctx.fillStyle = gr;
              ctx.beginPath();
              ctx.arc(xc + point.dx, yc + point.dy, dotRadius, 0, m2PI);
              ctx.fill();
            });
        }
      };

      function startOver() {
        // DPR 대응
        const dpr = window.devicePixelRatio || 1;

        // === [중요!] 110% 확대 및 오프셋 적용 ===
        maxx = window.innerWidth * 1.1;
        maxy = window.innerHeight * 1.1;

        canv.width = maxx * dpr;
        canv.height = maxy * dpr;

        // 확대와 오프셋
        canv.style.position = "absolute";
        canv.style.width = "110vw";
        canv.style.height = "110vh";
        canv.style.left = "-5vw";
        canv.style.top = "-5vh";

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.lineJoin = "bevel";
        ctx.lineCap = "round";

        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, maxx, maxy);

        xc = maxx / 2;
        yc = maxy / 2;

        R = 0.85 * mmin(xc, yc);
        const mind = R * minDist;
        dotRadius = mind / 2.1;

        arp = [];
        let ktry;
        exitArp: do {
          for (ktry = 1000; ktry > 0; --ktry) {
            let p = new Pos(R);
            let k1;
            for (k1 = arp.length - 1; k1 >= 0; --k1) {
              if (p.distance(arp[k1]) < mind) break;
            }
            if (k1 < 0) {
              arp.push(p);
              break;
            }
          }
        } while (ktry > 0);

        gr = ctx.createLinearGradient(0, maxy, maxx, 0);
        let hue = intAlea(360);
        let sat = intAlea(50, 100);
        gr.addColorStop(0, hslString(hue, sat, 60));
        gr.addColorStop(1, hslString(hue, sat, 90));

        return true;
      }

      function mouseClick(event) {
        messages.push({ message: "reset" });
      }

      canv = document.getElementById("canvas");
      ctx = canv.getContext("2d");

      dRot1 = Noise1DOneShot(500, -rotSpeed, rotSpeed);
      dRot2 = Noise1DOneShot(500, -rotSpeed, rotSpeed);

      canv.addEventListener("click", mouseClick);
      messages.push({ message: "reset" });
      window.requestAnimationFrame(animate);

      // === 창 크기 바뀌면 캔버스 리셋 ===
      window.addEventListener("resize", () => {
        messages.push({ message: "reset" });
      });
    }
  </script>
</body>
</html>
